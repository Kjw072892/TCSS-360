/* MinefieldGenerator.java
 * Generated by ChatGPT.
 */

package generator;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Generates a robust team_minesweeper_input.txt containing ≥15 fields, covering all edge cases
 * (1×1, long rows/cols, all-*, all-., non-square, plus some random ones), and ending with "0
 * 0".
 *
 * @author ChatGPT
 * @version 1.0
 */
public class MinefieldGenerator {

    /**
     * Name of the output file.
     */
    private static final String OUTPUT_FILE = "team_minesweeper_input.txt";

    /**
     * Random number generator.
     */
    private static final Random RNG = new Random(2025); // fixed seed for reproducibility

    /**
     * Generates a robust team_minesweeper_input.txt containing ≥15 fields, covering all edge
     * cases (1×1, long rows/cols, all-*, all-., non-square, plus some random ones), and ending
     * with "0 0".
     *
     * @param theArgs ignored
     * @throws FileNotFoundException if the output file cannot be created
     */
    public static void main(final String[] theArgs) throws FileNotFoundException {
        List<char[][]> fields = new ArrayList<>();

        // 1×1 edge cases
        fields.add(makeField(1, 1, true));
        fields.add(makeField(1, 1, false));

        // 1×100 and 100×1, both all-* and all-.
        fields.add(makeField(1, 100, true));
        fields.add(makeField(1, 100, false));
        fields.add(makeField(100, 1, true));
        fields.add(makeField(100, 1, false));

        // 100×100 all-* and all-.
        fields.add(makeField(100, 100, true));
        fields.add(makeField(100, 100, false));

        // Some non-square fixed examples
        fields.add(randomField(3, 5, 0.2));
        fields.add(randomField(7, 2, 0.5));
        fields.add(randomField(4, 6, 0.3));

        // A few medium random ones
        fields.add(randomField(10, 10, 0.15));
        fields.add(randomField(20, 5, 0.25));
        fields.add(randomField(5, 20, 0.4));
        fields.add(randomField(8, 8, 0.5));

        // Now write them out
        try (PrintWriter out = new PrintWriter(OUTPUT_FILE)) {
            for (char[][] f : fields) {
                out.printf("%d %d%n", f.length, f[0].length);
                for (char[] row : f) {
                    out.println(new String(row));
                }
            }
            // terminating zeroes
            out.println("0 0");
        }

        System.out.println("Generated " + fields.size() + " fields into " + OUTPUT_FILE);
    }

    /**
     * Creates a rows×cols field filled entirely with mines (*) if allMines==true, else
     * entirely with empty (.)
     *
     * @param theRows  the number of rows
     * @param theCols  the number of columns
     * @param theMines true if all cells should be mines
     * @return the field
     */
    private static char[][] makeField(final int theRows, final int theCols,
        final boolean theMines) {
        final char fill = theMines ? '*' : '.';
        final char[][] field = new char[theRows][theCols];
        for (int r = 0; r < theRows; r++) {
            for (int c = 0; c < theCols; c++) {
                field[r][c] = fill;
            }
        }
        return field;
    }

    /**
     * Creates a rows×cols field where each cell is a mine with probability p, else empty. p
     * between 0.0 and 1.0.
     *
     * @param theRows        the number of rows
     * @param theCols        the number of columns
     * @param theProbability the probability of a mine
     * @return the field
     */
    private static char[][] randomField(final int theRows, final int theCols,
        final double theProbability) {
        final char[][] field = new char[theRows][theCols];
        for (int r = 0; r < theRows; r++) {
            for (int c = 0; c < theCols; c++) {
                field[r][c] = (RNG.nextDouble() < theProbability) ? '*' : '.';
            }
        }
        return field;
    }
}
